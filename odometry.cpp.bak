#include "odometry.h"
#include <math.h>
#include <iostream>
#include <fstream>

typedef pcl::PointXYZRGB PointT;
using namespace std;

double calculate_cVal(vector<int> S,const pcl::PointXYZRGB& centerPoint,pcl::PointCloud<PointT>::Ptr cloud);
int setPoint2Red(pcl::PointXYZRGB& Point);
int setPoint2Green(pcl::PointXYZRGB& Point);
bool isPlanePoint(vector<double>& cVal,const pcl::PointXYZRGB& Point,pcl::KdTreeFLANN<PointT> kdtree);
bool isEdgePoint(vector<double>& cVal,const pcl::PointXYZRGB& Point,pcl::KdTreeFLANN<PointT> kdtree);
int read2PointCloud(std::string file2read,pcl::PointCloud<PointT>::Ptr cloud);
,0,-3.0,0,-1,0);
int main ()
{
    pcl::PointCloud<PointT>::Ptr cloud (new pcl::PointCloud<PointT>);

    std::string dir = "../../data/Pk_select/";
    std::string filename = "100_-1.XYZ";
/*
    if (pcl::io::loadPCDFile<PointT> ((dir+filename), *cloud) == -1)
    {
        // load the file
        PCL_ERROR ("Couldn't read PCD file \n");
        return (-1);
    }
    */
    if(read2PointCloud((dir+filename),cloud)==-1)
    {
        printf("can not open file %s!\n",(dir+filename));
        return -1;
    }
    printf("Loaded %d data points from PCD\n",
            cloud->width * cloud->height);


    for(int i=0;i<cloud->width*cloud->height;++i)
    {
        cloud->points[i].r=255;
        cloud->points[i].g=255;
        cloud->points[i].b=255;
        cloud->points[i].a=128;
    }
   /* pcl::PointCloud<PointT>::Ptr cloud_1 (new pcl::PointCloud<PointT>);
    int amount=(cloud->width*cloud->height)/16;
    for(int i=0;i<amount;++i)
    {
        cloud_1->push_back(cloud->points[amount+i]);
    }*/
    // creates kdtree object
    pcl::KdTreeFLANN<PointT> kdtree;
    // sets our randomly created cloud as the input
    kdtree.setInputCloud (cloud);
    //create a “searchPoint” which is assigned random coordinates
    PointT searchPoint;
    // K nearest neighbor search
    int K = 32;
    std::vector<int> pointIdxNKNSearch(K);
    std::vector<float> pointNKNSquaredDistance(K);
    std::vector<double> cVal;
    for(int cnt=0;cnt<cloud->width*cloud->height;++cnt)
    {
        searchPoint=cloud->points[cnt];

        if ( kdtree.nearestKSearch (searchPoint, K, pointIdxNKNSearch, pointNKNSquaredDistance) > 0 )
        {
            for(int i=0;i<K;++i)
                std::cout<<pointIdxNKNSearch[i]<<endl;
            cVal.push_back(calculate_cVal(pointIdxNKNSearch,searchPoint,cloud));
        }
    }
    for(int i=0;i<cVal.size();++i)
    {
        if(cVal[i]>0.01&&cVal[i]<0.015)
           setPoint2Red(cloud->points[i]);
        else if(cVal[i]<0.005)
            setPoint2Green(cloud->points[i]);
    }
    std::sort(cVal.begin(),cVal.end());
    for(int i=0;i<cVal.size();++i)
    {
        std::cout<<cVal[i]<<endl;
    }
    pcl::visualization::PCLVisualizer viewer("Cloud viewer");
    viewer.setCameraPosition(0,0,-3.0,0,-1,0);
    viewer.addCoordinateSystem(0.3);
    viewer.addPointCloud(cloud);
    /*pcl::visualization::PCLVisualizer viewer_1("Cloud_1 viewer");
    viewer_1.setCameraPosition(0,0,-3.0,0,-1,0);
    viewer_1.addCoordinateSystem(0.3);
    viewer_1.addPointCloud(cloud_1); */
    while(!viewer.wasStopped())//&&(!viewer_1.wasStopped()))
    {
        viewer.spinOnce(100);
//        viewer_1.spinOnce(100);
    }
    return (0);
}


double calculate_cVal(vector<int> S,const pcl::PointXYZRGB & centerPoint,pcl::PointCloud<PointT>::Ptr cloud)
{
    double cVal;
    int Ssize=S.size();
    double D_centerPoint=sqrt((centerPoint.x)*(centerPoint.x)+(centerPoint.y)*(centerPoint.y)+(centerPoint.z)*(centerPoint.z));
    pcl::PointXYZRGB sumPoint(0,0,0);
    double D_sum=0;
    for(int i=0;i<Ssize;++i)
    {
        sumPoint.x+=(centerPoint.x-cloud->points[S[i]].x);
        sumPoint.y+=(centerPoint.y-cloud->points[S[i]].y);
        sumPoint.z+=(centerPoint.z-cloud->points[S[i]].z);
    }
    D_sum=sqrt((sumPoint.x)*(sumPoint.x)+(sumPoint.y)*(sumPoint.y)+(sumPoint.z)*(sumPoint.z));
    cVal=D_sum/(Ssize*D_centerPoint);
    return cVal;
}


int setPoint2Red(pcl::PointXYZRGB& Point)
{
    Point.r=255;
    Point.g=0;
    Point.b=0;
    return 0;
}
int setPoint2Green(pcl::PointXYZRGB& Point)
{
    Point.r=0;
    Point.g=255;
    Point.b=0;
    return 0;
}


bool isPlanePoint(vector<double>& cVal,const pcl::PointXYZRGB& Point,pcl::KdTreeFLANN<PointT> kdtree)
{
    return false;
}
bool isEdgePoint(vector<double>& cVal,const pcl::PointXYZRGB& Point,pcl::KdTreeFLANN<PointT> kdtree)
{
    return false;
}

int read2PointCloud(std::string file2read,pcl::PointCloud<PointT>::Ptr cloud)
{
    double tmp_d=0;
    pcl::PointXYZRGB point;
    int cnt=0;
    ifstream data_in(file2read.c_str());
    if(!data_in.is_open())
        return -1;
    while(data_in>>tmp_d)
    {
        if(cnt%3==0)
            point.x=tmp_d;
        else if(cnt%3==1)
            point.y=tmp_d;
        else if(cnt%3==2)
            point.z=tmp_d;
        ++cnt;
        cloud->push_back(point);
    }
    data_in.close();
    return 0;
}
